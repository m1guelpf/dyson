use ensemble::{
	relationships::{BelongsTo, HasMany},
	types::{DateTime, Json, Uuid},
	Model,
};
use schemars::JsonSchema;
use url::Url;

#[derive(Debug, Clone, Model, JsonSchema)]
pub struct User {
	#[model(uuid)]
	pub id: Uuid,
	pub username: String,
	pub created_at: DateTime,
	pub updated_at: DateTime,

	pub api_tokens: HasMany<User, ApiToken>,
	pub predictions: HasMany<User, Prediction>,
}

#[derive(Debug, Clone, Model, JsonSchema)]
pub struct ApiToken {
	pub name: String,
	#[model(primary, hide)]
	pub token: String,
	pub created_at: DateTime,
	pub updated_at: DateTime,

	pub user: BelongsTo<ApiToken, User>,
}

/// The events that can trigger a webhook.
#[derive(Debug, serde::Serialize, serde::Deserialize, JsonSchema, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum WebhookEvent {
	/// Immediately on prediction start.
	Start,
	/// Each time a prediction generates an output (note that predictions can generate multiple outputs)
	Output,
	/// Each time log output is generated by a prediction
	Logs,
	/// When the prediction reaches a terminal state (succeeded/canceled/failed)
	Completed,
}

#[derive(Debug, serde::Serialize, serde::Deserialize, JsonSchema, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PredictionStatus {
	Starting,
	Processing,
	Succeeded,
	Failed,
	Cancelled,
}

#[derive(Debug, Clone, Model, JsonSchema)]
pub struct Prediction {
	#[model(uuid)]
	pub id: Uuid,
	pub version: String,
	#[model(default = PredictionStatus::Starting)]
	pub status: PredictionStatus,
	pub webhook_url: Option<Url>,
	#[model(default)]
	pub webhook_filter: Json<Vec<WebhookEvent>>,

	pub logs: Option<String>,
	pub input: Json,
	pub error: Option<Json>,
	pub output: Option<Json>,
	pub metrics: Option<Json>,

	pub created_at: DateTime,
	pub updated_at: DateTime,
	pub started_at: Option<DateTime>,
	pub completed_at: Option<DateTime>,

	pub user: BelongsTo<Prediction, User>,
}
