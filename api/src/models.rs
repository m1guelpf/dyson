use ensemble::{
	relationships::{BelongsTo, HasMany},
	types::DateTime,
	Model,
};
use schemars::JsonSchema;
use url::Url;
use uuid::Uuid;

#[derive(Debug, Clone, Model, JsonSchema)]
pub struct User {
	#[model(uuid)]
	pub id: Uuid,
	pub username: String,
	pub created_at: DateTime,
	pub updated_at: DateTime,

	pub api_tokens: HasMany<User, ApiToken>,
	pub predictions: HasMany<User, Prediction>,
}

#[derive(Debug, Clone, Model, JsonSchema)]
pub struct ApiToken {
	pub name: String,
	#[model(primary, hide)]
	pub token: String,
	pub created_at: DateTime,
	pub updated_at: DateTime,

	pub user: BelongsTo<ApiToken, User>,
}

/// The events that can trigger a webhook.
#[derive(Debug, serde::Serialize, serde::Deserialize, JsonSchema, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum WebhookEvent {
	/// Immediately on prediction start.
	Start,
	/// Each time a prediction generates an output (note that predictions can generate multiple outputs)
	Output,
	/// Each time log output is generated by a prediction
	Logs,
	/// When the prediction reaches a terminal state (succeeded/canceled/failed)
	Completed,
}

#[derive(
	Debug, serde::Serialize, serde::Deserialize, JsonSchema, Clone, Copy, PartialEq, Eq, Default,
)]
#[serde(rename_all = "lowercase")]
pub enum PredictionStatus {
	#[default]
	Starting,
	Processing,
	Succeeded,
	Failed,
	Cancelled,
}

#[derive(Debug, Clone, Model, JsonSchema)]
pub struct Prediction {
	#[model(uuid)]
	pub id: Uuid,
	pub status: PredictionStatus,
	pub version: String,
	pub logs: Option<String>,
	pub webhook_url: Option<Url>,
	pub webhook_filter: Vec<WebhookEvent>,

	pub input: serde_json::Value,
	pub error: Option<serde_json::Value>,
	pub output: Option<serde_json::Value>,
	pub metrics: Option<serde_json::Value>,

	pub created_at: DateTime,
	pub updated_at: DateTime,

	pub user: BelongsTo<Prediction, User>,
}
