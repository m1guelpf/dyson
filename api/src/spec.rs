use schemars::JsonSchema;
use url::Url;

use crate::db::{api_token, predictions, user};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, JsonSchema)]
pub struct User {
	pub username: user::username::Type,
	pub created_at: user::created_at::Type,
	pub updated_at: user::updated_at::Type,

	#[serde(skip_serializing_if = "Option::is_none")]
	pub tokens: Option<Vec<ApiToken>>,

	#[serde(skip_serializing_if = "Option::is_none")]
	pub predictions: Option<Vec<Prediction>>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, JsonSchema)]
pub struct ApiToken {
	pub name: api_token::name::Type,
	pub token: api_token::token::Type,
	pub user_id: api_token::user_id::Type,
	pub created_at: api_token::created_at::Type,
	pub updated_at: api_token::updated_at::Type,

	#[serde(skip_serializing_if = "Option::is_none")]
	pub user: Option<User>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, JsonSchema)]
pub struct Prediction {
	pub id: predictions::id::Type,
	#[serde(skip_serializing_if = "always_hide_on_serialization")]
	pub user_id: predictions::user_id::Type,
	pub version: predictions::version::Type,
	pub status: PredictionStatus,
	pub input: predictions::input::Type,
	pub output: predictions::output::Type,
	pub error: predictions::error::Type,
	pub logs: predictions::logs::Type,
	pub metrics: predictions::metrics::Type,
	#[serde(skip_serializing_if = "always_hide_on_serialization")]
	pub webhook_url: Option<Url>,
	#[serde(skip_serializing_if = "always_hide_on_serialization")]
	pub webhook_filter: Vec<WebhookEvent>,
	pub created_at: predictions::created_at::Type,
	pub updated_at: predictions::updated_at::Type,
	pub started_at: predictions::started_at::Type,
	pub completed_at: predictions::completed_at::Type,

	#[serde(skip_serializing_if = "Option::is_none")]
	pub user: Option<User>,
}

#[derive(Debug, serde::Serialize, serde::Deserialize, JsonSchema, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PredictionStatus {
	Starting,
	Processing,
	Succeeded,
	Failed,
	Cancelled,
}

/// The events that can trigger a webhook.
#[derive(Debug, serde::Serialize, serde::Deserialize, JsonSchema, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum WebhookEvent {
	/// Immediately on prediction start.
	Start,
	/// Each time a prediction generates an output (note that predictions can generate multiple outputs)
	Output,
	/// Each time log output is generated by a prediction
	Logs,
	/// When the prediction reaches a terminal state (succeeded/canceled/failed)
	Completed,
}

impl From<user::Data> for User {
	fn from(user: user::Data) -> Self {
		Self {
			username: user.username,
			updated_at: user.updated_at,
			created_at: user.created_at,
			predictions: user
				.predictions
				.map(|predictions| predictions.into_iter().map(Into::into).collect()),
			tokens: user
				.tokens
				.map(|tokens| tokens.into_iter().map(Into::into).collect()),
		}
	}
}

impl From<api_token::Data> for ApiToken {
	fn from(token: api_token::Data) -> Self {
		Self {
			name: token.name,
			token: token.token,
			user_id: token.user_id,
			updated_at: token.updated_at,
			created_at: token.created_at,
			user: token.user.map(|u| (*u).into()),
		}
	}
}

impl From<predictions::Data> for Prediction {
	fn from(value: predictions::Data) -> Self {
		Self {
			id: value.id,
			logs: value.logs,
			input: value.input,
			error: value.error,
			output: value.output,
			user_id: value.user_id,
			version: value.version,
			metrics: value.metrics,
			status: value.status.into(),
			updated_at: value.updated_at,
			created_at: value.created_at,
			started_at: value.started_at,
			webhook_url: value.webhook_url.map(|s| Url::parse(&s).unwrap()),
			completed_at: value.completed_at,
			user: value.user.map(|u| (*u).into()),
			webhook_filter: value
				.webhook_filter
				.into_iter()
				.map(Into::into)
				.collect::<Vec<_>>(),
		}
	}
}

impl From<predictions::status::Type> for PredictionStatus {
	fn from(value: predictions::status::Type) -> Self {
		match value {
			predictions::status::Type::Failed => Self::Failed,
			predictions::status::Type::Starting => Self::Starting,
			predictions::status::Type::Processing => Self::Processing,
			predictions::status::Type::Succeeded => Self::Succeeded,
			predictions::status::Type::Cancelled => Self::Cancelled,
		}
	}
}

impl From<WebhookEvent> for String {
	fn from(value: WebhookEvent) -> Self {
		match value {
			WebhookEvent::Logs => "logs".into(),
			WebhookEvent::Start => "start".into(),
			WebhookEvent::Output => "output".into(),
			WebhookEvent::Completed => "completed".into(),
		}
	}
}

#[allow(clippy::fallible_impl_from)]
impl From<String> for WebhookEvent {
	fn from(value: String) -> Self {
		match value.as_str() {
			"logs" => Self::Logs,
			"start" => Self::Start,
			"output" => Self::Output,
			"completed" => Self::Completed,
			_ => panic!("Invalid webhook event"),
		}
	}
}

const fn always_hide_on_serialization<T>(_: &T) -> bool {
	true
}
